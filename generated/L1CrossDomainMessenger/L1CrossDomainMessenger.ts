// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class FailedRelayedMessage extends ethereum.Event {
  get params(): FailedRelayedMessage__Params {
    return new FailedRelayedMessage__Params(this);
  }
}

export class FailedRelayedMessage__Params {
  _event: FailedRelayedMessage;

  constructor(event: FailedRelayedMessage) {
    this._event = event;
  }

  get msgHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class MessageAllowed extends ethereum.Event {
  get params(): MessageAllowed__Params {
    return new MessageAllowed__Params(this);
  }
}

export class MessageAllowed__Params {
  _event: MessageAllowed;

  constructor(event: MessageAllowed) {
    this._event = event;
  }

  get _xDomainCalldataHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class MessageBlocked extends ethereum.Event {
  get params(): MessageBlocked__Params {
    return new MessageBlocked__Params(this);
  }
}

export class MessageBlocked__Params {
  _event: MessageBlocked;

  constructor(event: MessageBlocked) {
    this._event = event;
  }

  get _xDomainCalldataHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Paused extends ethereum.Event {
  get params(): Paused__Params {
    return new Paused__Params(this);
  }
}

export class Paused__Params {
  _event: Paused;

  constructor(event: Paused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class RelayedMessage extends ethereum.Event {
  get params(): RelayedMessage__Params {
    return new RelayedMessage__Params(this);
  }
}

export class RelayedMessage__Params {
  _event: RelayedMessage;

  constructor(event: RelayedMessage) {
    this._event = event;
  }

  get msgHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class SentMessage extends ethereum.Event {
  get params(): SentMessage__Params {
    return new SentMessage__Params(this);
  }
}

export class SentMessage__Params {
  _event: SentMessage;

  constructor(event: SentMessage) {
    this._event = event;
  }

  get target(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get message(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get messageNonce(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get gasLimit(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class Unpaused extends ethereum.Event {
  get params(): Unpaused__Params {
    return new Unpaused__Params(this);
  }
}

export class Unpaused__Params {
  _event: Unpaused;

  constructor(event: Unpaused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class L1CrossDomainMessenger extends ethereum.SmartContract {
  static bind(address: Address): L1CrossDomainMessenger {
    return new L1CrossDomainMessenger("L1CrossDomainMessenger", address);
  }

  blockedMessages(param0: Bytes): boolean {
    let result = super.call(
      "blockedMessages",
      "blockedMessages(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBoolean();
  }

  try_blockedMessages(param0: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "blockedMessages",
      "blockedMessages(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  libAddressManager(): Address {
    let result = super.call(
      "libAddressManager",
      "libAddressManager():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_libAddressManager(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "libAddressManager",
      "libAddressManager():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  paused(): boolean {
    let result = super.call("paused", "paused():(bool)", []);

    return result[0].toBoolean();
  }

  try_paused(): ethereum.CallResult<boolean> {
    let result = super.tryCall("paused", "paused():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  relayedMessages(param0: Bytes): boolean {
    let result = super.call(
      "relayedMessages",
      "relayedMessages(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBoolean();
  }

  try_relayedMessages(param0: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "relayedMessages",
      "relayedMessages(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  resolve(_name: string): Address {
    let result = super.call("resolve", "resolve(string):(address)", [
      ethereum.Value.fromString(_name)
    ]);

    return result[0].toAddress();
  }

  try_resolve(_name: string): ethereum.CallResult<Address> {
    let result = super.tryCall("resolve", "resolve(string):(address)", [
      ethereum.Value.fromString(_name)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  successfulMessages(param0: Bytes): boolean {
    let result = super.call(
      "successfulMessages",
      "successfulMessages(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBoolean();
  }

  try_successfulMessages(param0: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "successfulMessages",
      "successfulMessages(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  xDomainMessageSender(): Address {
    let result = super.call(
      "xDomainMessageSender",
      "xDomainMessageSender():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_xDomainMessageSender(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "xDomainMessageSender",
      "xDomainMessageSender():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AllowMessageCall extends ethereum.Call {
  get inputs(): AllowMessageCall__Inputs {
    return new AllowMessageCall__Inputs(this);
  }

  get outputs(): AllowMessageCall__Outputs {
    return new AllowMessageCall__Outputs(this);
  }
}

export class AllowMessageCall__Inputs {
  _call: AllowMessageCall;

  constructor(call: AllowMessageCall) {
    this._call = call;
  }

  get _xDomainCalldataHash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class AllowMessageCall__Outputs {
  _call: AllowMessageCall;

  constructor(call: AllowMessageCall) {
    this._call = call;
  }
}

export class BlockMessageCall extends ethereum.Call {
  get inputs(): BlockMessageCall__Inputs {
    return new BlockMessageCall__Inputs(this);
  }

  get outputs(): BlockMessageCall__Outputs {
    return new BlockMessageCall__Outputs(this);
  }
}

export class BlockMessageCall__Inputs {
  _call: BlockMessageCall;

  constructor(call: BlockMessageCall) {
    this._call = call;
  }

  get _xDomainCalldataHash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class BlockMessageCall__Outputs {
  _call: BlockMessageCall;

  constructor(call: BlockMessageCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _libAddressManager(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class PauseCall extends ethereum.Call {
  get inputs(): PauseCall__Inputs {
    return new PauseCall__Inputs(this);
  }

  get outputs(): PauseCall__Outputs {
    return new PauseCall__Outputs(this);
  }
}

export class PauseCall__Inputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class PauseCall__Outputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class RelayMessageCall extends ethereum.Call {
  get inputs(): RelayMessageCall__Inputs {
    return new RelayMessageCall__Inputs(this);
  }

  get outputs(): RelayMessageCall__Outputs {
    return new RelayMessageCall__Outputs(this);
  }
}

export class RelayMessageCall__Inputs {
  _call: RelayMessageCall;

  constructor(call: RelayMessageCall) {
    this._call = call;
  }

  get _target(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _sender(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _message(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get _messageNonce(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _proof(): RelayMessageCall_proofStruct {
    return changetype<RelayMessageCall_proofStruct>(
      this._call.inputValues[4].value.toTuple()
    );
  }
}

export class RelayMessageCall__Outputs {
  _call: RelayMessageCall;

  constructor(call: RelayMessageCall) {
    this._call = call;
  }
}

export class RelayMessageCall_proofStruct extends ethereum.Tuple {
  get stateRoot(): Bytes {
    return this[0].toBytes();
  }

  get stateRootBatchHeader(): RelayMessageCall_proofStateRootBatchHeaderStruct {
    return changetype<RelayMessageCall_proofStateRootBatchHeaderStruct>(
      this[1].toTuple()
    );
  }

  get stateRootProof(): RelayMessageCall_proofStateRootProofStruct {
    return changetype<RelayMessageCall_proofStateRootProofStruct>(
      this[2].toTuple()
    );
  }

  get stateTrieWitness(): Bytes {
    return this[3].toBytes();
  }

  get storageTrieWitness(): Bytes {
    return this[4].toBytes();
  }
}

export class RelayMessageCall_proofStateRootBatchHeaderStruct extends ethereum.Tuple {
  get batchIndex(): BigInt {
    return this[0].toBigInt();
  }

  get batchRoot(): Bytes {
    return this[1].toBytes();
  }

  get batchSize(): BigInt {
    return this[2].toBigInt();
  }

  get prevTotalElements(): BigInt {
    return this[3].toBigInt();
  }

  get extraData(): Bytes {
    return this[4].toBytes();
  }
}

export class RelayMessageCall_proofStateRootProofStruct extends ethereum.Tuple {
  get index(): BigInt {
    return this[0].toBigInt();
  }

  get siblings(): Array<Bytes> {
    return this[1].toBytesArray();
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class ReplayMessageCall extends ethereum.Call {
  get inputs(): ReplayMessageCall__Inputs {
    return new ReplayMessageCall__Inputs(this);
  }

  get outputs(): ReplayMessageCall__Outputs {
    return new ReplayMessageCall__Outputs(this);
  }
}

export class ReplayMessageCall__Inputs {
  _call: ReplayMessageCall;

  constructor(call: ReplayMessageCall) {
    this._call = call;
  }

  get _target(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _sender(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _message(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get _queueIndex(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _oldGasLimit(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _newGasLimit(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }
}

export class ReplayMessageCall__Outputs {
  _call: ReplayMessageCall;

  constructor(call: ReplayMessageCall) {
    this._call = call;
  }
}

export class SendMessageCall extends ethereum.Call {
  get inputs(): SendMessageCall__Inputs {
    return new SendMessageCall__Inputs(this);
  }

  get outputs(): SendMessageCall__Outputs {
    return new SendMessageCall__Outputs(this);
  }
}

export class SendMessageCall__Inputs {
  _call: SendMessageCall;

  constructor(call: SendMessageCall) {
    this._call = call;
  }

  get _target(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _message(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _gasLimit(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SendMessageCall__Outputs {
  _call: SendMessageCall;

  constructor(call: SendMessageCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}
